function [outputArg1,outputArg2] = inference_routine(tile_1, tile_2, max_weight, n_kernels, kernel_sizes, test_data, n_samples)
    V_BL = zeros(64,1); %Ground column voltages (set columns to 0 V)
    R_source = 20; % 20-50 source resistance (ohms) for simulation model
    R_line = 2;   % 2-5 line resistance (ohms) for simulation model
    R_max = 100E3; %100 kohm is max resistance of memristors
    R_min = 10E3;  %10 kohm is min resistance of memristors
    rminrange = [0.95,1]; %limit for min_R [1,1] to turn off
    rmaxrange = [1,1.05]; %limit for max_R [1,1] to turn off
    rmaxlimit = rmaxrange(1)+rand(1,8).*(rmaxrange(2)-rmaxrange(1));
    rminlimit = rminrange(1)+rand(1,8).*(rminrange(2)-rminrange(1));
    R_max = R_max.*rmaxlimit;
    R_min = R_min.*rminlimit;
    G_max = 1./R_min; % Calculate max conductance based on resistance
    G_min = 1./R_max; % Calculate min conductance based on resistance
    output_bits = 6;
    scaling_factor = (G_max - G_min)./max_weight;
    for sample_idx = 1:n_samples+1
        disp(sample_idx);
        input_vec = test_data(:, sample_idx); % Input vector
        input_vec = input_vec';
        % Forward operation for tiles 1 and 2 (convolution)
        conv_out = zeros(128 - kernel_sizes(1) - kernel_sizes(2) + 2, n_kernels);
        % First convolution
        for i = 1:(64 - kernel_sizes(1) + 1)
            V_WL = [1, input_vec(i:i+kernel_sizes(1)-1), zeros(1, kernel_sizes(2)+1)];
            [~, I_temp, ~] = voltage_deg_model_sparse_conductance(tile_1, V_WL, V_BL, R_source, R_line);
            I_temp = (I_temp - G_min(1)) ./ scaling_factor(1);
            pos_I = I_temp(:, 1:2:end);
            neg_I = I_temp(:, 2:2:end);
            conv_out(i, 1:end) = pos_I - neg_I;
        end
        % Second convolution
        for i = 1:(64 - kernel_sizes(2) + 1)
            V_WL = [1, input_vec(i:i+kernel_sizes(2)-1), zeros(1, kernel_sizes(1)+1),];
            [~, I_temp, ~] = voltage_deg_model_sparse_conductance(tile_2, V_WL, V_BL, R_source, R_line);
            I_temp = (I_temp - G_min(2)) ./ scaling_factor(2);
            pos_I = I_temp(:, 1:2:end);
            neg_I = I_temp(:, 2:2:end);
            conv_out(i + 64 - kernel_sizes(1) + 1, 1:end) = pos_I - neg_I;
        end
        % Implement output resolution
        conv_outstep = (max(max(conv_out)) - min(min(conv_out)))./(2^output_bits-1);
        conv_out = round(conv_out./conv_outstep)*conv_outstep;
        % Apply ReLU
        conv_out(conv_out<0)=0;
        % Forward operation for tile 8 (avgerage pooling)
        avgpool_out = zeros(34, 32);
        for i=1:2:68
            for j=1:32
                if i==1
                    avgpool_out(1,j) = 0.5*conv_out(i,j)+0.5*conv_out(i+1,j);
                else
                    avgpool_out((i+1)/2,j) = 0.5*conv_out(i,j)+0.5*conv_out(i+1,j);
                end
            end
        end
        % Apply ReLU
        avgpool_out(avgpool_out<0)=0;
        %Forward operation for tile 3-7 (first dense layer with 8 neurons)
        % Reformat the output from previous layer
        %avgpool_out = permute(avgpool_out,[2,1]);
        avgpool_out = reshape(avgpool_out,[1088,1]);

        %Perform calculation
        total = zeros(1,16);
        reading = [1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64,1,16,17,32,33,48,49,64];
        for i=1:17 %1088/64=17
            if (1<=i) && (i<=4)
                V_WL = [avgpool_out(((i-1)*64+1):i*64,:)];
                [VM_temp, I_temp, P_temp] = voltage_deg_model_sparse_conductance(dense1a,V_WL,V_BL,R_source,R_line);
                tempI=(I_temp(reading(1,(i*2-1)):reading(1,i*2))-G_min(3))./scaling_factor(3);
                total = total+tempI;
            elseif (5<=i) && (i<=8)
                V_WL = [avgpool_out(((i-1)*64+1):i*64,:)];
                [VM_temp, I_temp, P_temp] = voltage_deg_model_sparse_conductance(dense1b,V_WL,V_BL,R_source,R_line);
                tempI=(I_temp(reading(1,(i*2-1)):reading(1,i*2))-G_min(4))./scaling_factor(4);
                total = total+tempI;
            elseif (9<=i) && (i<=12)
                V_WL = [avgpool_out(((i-1)*64+1):i*64,:)];
                [VM_temp, I_temp, P_temp] = voltage_deg_model_sparse_conductance(dense1c,V_WL,V_BL,R_source,R_line);
                tempI=(I_temp(reading(1,(i*2-1)):reading(1,i*2))-G_min(5))./scaling_factor(5);
                total = total+tempI;
            elseif (13<=i) && (i<=16)
                V_WL = [avgpool_out(((i-1)*64+1):i*64,:)];
                [VM_temp, I_temp, P_temp] = voltage_deg_model_sparse_conductance(dense1d,V_WL,V_BL,R_source,R_line);
                tempI=(I_temp(reading(1,(i*2-1)):reading(1,i*2))-G_min(6))./scaling_factor(6);
                total = total+tempI;
            else
                V_WL = [avgpool_out(((i-1)*64+1):i*64,:)];
                [VM_temp, I_temp, P_temp] = voltage_deg_model_sparse_conductance(dense1e,V_WL,V_BL,R_source,R_line);
                tempI=(I_temp(reading(1,(i*2-1)):reading(1,i*2))-G_min(7))./scaling_factor(7);
                total = total+tempI;
            end
        end

        %Add bias
        total = total+dense1b_diff;

        % Implement output resolution
        totalstep = (max(max(total)) - min(min(total)))./(2^outputbits-1);
        total = round(total./totalstep)*totalstep;

        %Convert back from differential form and apply relu
        pos_I = total(:,1:2:end);
        neg_I = total(:,2:2:end);
        dense1_out = pos_I-neg_I;
        %dense1_out(dense1_out<0)=0;



        %% Forward operation for 1 (second dense layer with 2 neurons)

        a = size(dense1_out);
        V_WL = [zeros(1,kernel_sizes(1)+1),dense1_out,zeros(1,64-8-kernel_sizes(1))];
        [VM_temp, I_temp, P_temp] = voltage_deg_model_sparse_conductance(tile_1,V_WL,V_BL,R_source,R_line);
        tempI=(I_temp(1:4)-G_min(1))./scaling_factor(1);
        pos_I = tempI(:,1:2:end);
        neg_I = tempI(:,2:2:end);
        dense2_out = pos_I-neg_I;
        dense2_out=dense2_out+dense2b;

        % Implement output resolution
        dense2_outstep = (max(max(dense2_out)) - min(min(dense2_out)))./(2^outputbits-1);
        dense2_out = round(dense2_out./dense2_outstep)*dense2_outstep;



        %% Convert to final prediction
        [maxNum,maxIndex]=max(dense2_out);
        predictions = [predictions,maxIndex-1];

        %% List comparison and calculate accuracy
        dif = predictions-testlabel(1,start_num:sample_idx);
        dif(dif<0)=1;
        [rown,coln] = size(predictions);
        accuracy = (coln-sum(dif))./coln
    end
end

